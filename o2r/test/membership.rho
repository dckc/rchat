new insertArbitrary(`rho:registry:insertArbitrary`), stdout(`rho:io:stdout`), debug(`rho:io:stderr`) in {
  new membership, store, return in {
    // Insert the name into the registry
    // Wrap in bundle+ so only write is possible for those who lookup
    insertArbitrary!(bundle+{*membership}, *return) |

    // Receive the URI generated by the registry
    for (@xUri <- return) {
      // Something like: `rho:id:rtu77e1cj1ky7dpqyoc6o8rcdseseax35qi7w37hbf3astmrcupusi`
      stdout!(["registerd membershp contract at:", xUri])
    }
    |
    store!({})
    |
    contract membership(@"add", @cert, return) = {
      // debug!("membership(...")|
      match cert {
        {@"claim"!(
          {claim /\ {@"binding"!(
            @"discord"!(@"id"!(discordId) | _rest1)
              |@"publicKey"!(publicKey)) | _rest2}}) |
          @"endorsement"!(endorsement)} => {
          debug!(["ready to check:", discordId, claim, endorsement])
          |
          new checkResult in {
            @"ed25519Verify"!(claim.toByteArray(), endorsement.hexToBytes(),
              // springboard PK
              "1ad20b9fe34e2ab5715940ae2048d907ce7908921ca1dfd9763f0eb03dcb3f73".hexToBytes(),
              *checkResult) |
            for (@sigOk <- checkResult) {
              debug!(["sigOK?", sigOk]) |
              if(sigOk) {
                for (@old <- store) {
                  store!(old.set(discordId, cert)) |
                  // what to return? How about the key to the store...
                  return!(discordId)
                }
              } else {
                return!(Nil)
              }
            }
          }
        }
      }
    }
    |
    contract membership(@"lookup", @id, return) = {
      // debug!(["lookup", id]) |
      for(@db <- store) {
        // debug!(["found:", db.get(id)])|
        store!(db) |  // wishing for peek...
        return!(db.get(id))
      }
    }
    |
    // Testing...

    new added, found in {
      membership!("add",
        {
          @"claim"!(@"binding"!(@"discord"!(@"guild"!("257555930173014017") |
            @"id"!("358096357862408195") |
            @"role"!("412648251196702741") |
            @"userName"!("dckc#3040")) |
            @"publicKey"!("ebede01df79043137cf8a42a4989c755ce503bdf8064bfa161a9cb48f401784f")) |
            @"memberSigTime"!("2018-10-22T03:30") |
            @"memberSignature"!("f51bc1a6cb68e121c16ccf00240367b669bc24fbf22da69e5669157bf3dee24550c67200e18cc7d136825c5910fb825ff7b32b0a5739e949857ff482d5199508")) |
          @"endorsement"!("cc29b8a40cebe4bc6bfa9b4df5c7572db72f4f78f38af82f2ed08eab991a25dab1e9d615dd18a4d3156fb156a1dd5d01ce8ec6fd5adb2e12fc5bfce6c1888a0c")
        }, *added)
      |
      for (@what <- added) {
        debug!(["added", what]) |
        membership!("lookup", "358096357862408195", *found) |
        for (@it <- found) {
          stdout!(["lookup got:", it])
        }
      }
    }
  }
  |

  new x in {
    @"ed25519Verify"!(
      {
@"binding"!(@"discord"!(@"guild"!("257555930173014017") |
            @"id"!("358096357862408195") |
            @"role"!("412648251196702741") |
            @"userName"!("dckc#3040")) |
            @"publicKey"!("ebede01df79043137cf8a42a4989c755ce503bdf8064bfa161a9cb48f401784f")) |
            @"memberSigTime"!("2018-10-22T03:30") |
        @"memberSignature"!("f51bc1a6cb68e121c16ccf00240367b669bc24fbf22da69e5669157bf3dee24550c67200e18cc7d136825c5910fb825ff7b32b0a5739e949857ff482d5199508")
      }.toByteArray(),
      "cc29b8a40cebe4bc6bfa9b4df5c7572db72f4f78f38af82f2ed08eab991a25dab1e9d615dd18a4d3156fb156a1dd5d01ce8ec6fd5adb2e12fc5bfce6c1888a0c".hexToBytes(),
      "1ad20b9fe34e2ab5715940ae2048d907ce7908921ca1dfd9763f0eb03dcb3f73".hexToBytes(),
      *x) |
    for(@ok <- x) {
      debug!(["sig result:", ok])
    }
  }
}
