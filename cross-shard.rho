new BallotFactory, LockoutFactory, MailBoxFactory, DepositoryFactory, MintFactory, r(`rho:registry:lookup`) in {
  // create: create a ballot
  //
  //  string algorithm: name of public key algorithm to use 
  //  Set<bytearray> pubKeySet: set of public keys allowed to vote on this ballot
  //  integer voteQuorumSize: 0 < voteQuorumSize < pubKeySet.size() required for candidate to win
  //  integer cancelQuorumSize: 0 < cancelQuorumSize < pubKeySet.size() required for election to be canceled
  //  ch(process) winnerOut: send winning candidate on this
  //  ch({"result": false, "reason": string} \/ {"result": true, "ballot": Ballot}) ballotOut: send resulting ballot on this
  //
  // TODO(pyrocto): Need to track whether there are enough outstanding votes to get a quorum.  If not, fail.
  contract @[*BallotFactory, "create"](@algorithm /\ String, @pubKeySet, @voteQuorumSize /\ Int, @cancelQuorumSize /\ Int, winnerOut, ballotOut) = {
    new ballot, votedSetStore, voteMapStore, canceledSetStore, doneStore, verifyStore, 
        ed25519Verify(`rho:crypto:ed25519Verify`), secp256k1Verify(`rho:crypto:secp256k1Verify`), ret,
        guardedBallotOut in {
      // Type guard for ballotOut
      for (@msg <- guardedBallotOut) {
        match msg {
          {"result": false, "reason": String} => ballotOut!(msg)
          {"result": true, "ballot": _} => ballotOut!(msg)
          _ => ballotOut!({"result": false, "reason": "Internal error!"})
        }
      } |
      new verifyStore in {
        if (algorithm == "ed25519") {
          verifyStore!(*ed25519Verify)
        } else if (algorithm == "secp256k1") {
          verifyStore!(*secp256k1Verify)
        } else {
          guardedBallotOut!({"result": false, "reason": "Unrecognized public key algorithm"})
        }
      } |
      @[*r, "register"]!(`rho:uuid`, bundle+{*ballot}, *ret) |
      for (@[uuid, unregisterBallotToken] <- ret; verify <- verifyStore) {
        guardedBallotOut!({"result": true, "ballot": *ballot}) |
      
        // Stores set of keys that have voted
        votedSetStore!(Set()) |
        // Stores map of candidate to count
        // TODO: when there's a method to get the set of keys from the map, use that instead of votedsStore
        voteMapStore!({}) |
        // Stores set of keys that have canceled
        canceledSetStore!(Set()) |
        // Whether the ballot has completed
        doneStore!(false) |
    
        // vote: records the vote of the given public key for the given candidate on this ballot
        //
        //  bytearray pubKey: the public key to vote with
        //  any canditate: the candidate to vote for
        //  name statusOut: send success/failure notification on this
        //  bytearray sig: signature of [*ballot, candidate, *statusOut].toByteArray()
        contract @[*ballot, "vote"](@pubKey, @candidate, statusOut, @sig) = {
          for (@done <- doneStore; @votedSet <- votedSetStore) {
            if (done) {
              votedSetStore!(votedSet) |
              doneStore!(true) |
              statusOut!({"result": false, "reason": "Already done."})
            } else {
              // check that the pubkey is in the list
              if (not pubKeySet.contains(pubKey)) {
                votedSetStore!(votedSet) |
                doneStore!(false) |
                statusOut!({"result": false, "reason": "Invalid key."})
              } else {
                if (votedSet.contains(pubKey)) {
                  votedSetStore!(votedSet) |
                  doneStore!(done) |
                  statusOut!({"result": false, "reason": "Already voted."})
                } else {
                  // check the signature
                  new ret in {
                    verify!([*ballot, candidate, *statusOut].toByteArray(), sig, pubKey, *ret) |
                    for (@verifyResult <- ret) {
                      if (not verifyResult) {
                        votedSetStore!(votedSet) |
                        doneStore!(false) |
                        statusOut!({"result": false, "reason": "Invalid signature."})
                      } else {
                        votedSetStore!(votedSet.add(pubKey)) |
                        new currentCountOut, newCountOut in {
                          // Increment the candidate's vote count
                          for (@voteMap <- voteMapStore) {
                            currentCountOut!(voteMap.get(candidate)) |
                            for (@currentCount <- currentCountOut) {
                              if (currentCount == Nil) {
                                voteMapStore!(voteMap.set(candidate, 1)) |
                                newCountOut!(1)
                              } else {
                                voteMapStore!(voteMap.set(candidate, currentCount + 1)) |
                                newCountOut!(currentCount + 1)
                              } |
                              for (@newCount <- newCountOut) {
                                // Check quorum size
                                if (newCount < voteQuorumSize) {
                                  statusOut!({"result": true, "done": false}) |
                                  doneStore!(false)
                                } else {
                                  // Remove ballot from the registry so it can be garbage collected
                                  @[*r, "unregister"]!(unregisterBallotToken, Nil) |
                                  winnerOut!(candidate) |
                                  statusOut!({"result": true, "done": true}) |
                                  doneStore!(true)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } |
    
        // cancel: votes to cancel the ballot instead of waiting for remaining keys to vote
        //
        //  bytearray pubKey: the public key to vote with
        //  name statusOut: send success/failure notification on this
        //  bytearray sig: signature of [*ballot, *statusOut].toByteArray()
        contract @[*ballot, "cancel"](@pubKey, statusOut, @sig) = {
          for (@done <- doneStore; @canceledSet <- canceledSetStore) {
            if (done) {
              canceledSetStore!(canceledSet) |
              doneStore!(done) |
              statusOut!({"result": false, "reason": "Already done."})
            } else {
              // check that the pubkey is in the list
              if (not pubKeySet.contains(pubKey)) {
                canceledSetStore!(canceledSet) |
                doneStore!(done) |
                statusOut!(["fail", "Invalid key."])
              } else {
                // check that it hasn't already cast its vote to cancel
                if (canceledSet.contains(pubKey)) {
                  canceledSetStore!(canceledSet) |
                  doneStore!(done) |
                  statusOut!({"result": false, "reason": "Already canceled."})
                } else {
                  // check the signature
                  new ret in {
                    verify!([*ballot, *statusOut].toByteArray(), sig, pubKey, *ret) |
                    for (@verifyResult <- ret) {
                      if (not verifyResult) {
                        canceledSetStore!(canceledSet) |
                        doneStore!(done) |
                        statusOut!({"result": false, "reason": "Invalid signature."})
                      } else {
                        // Add the public key to the set of cancelers
                        // TODO(pyrocto): verify that this can be simplified to just
                        //   canceledSetStore!(canceledSet.add(pubKey)) |
                        //   if (canceledSet.size() + 1 < cancelQuorumSize) { ... } else { ... }
                        //   (i.e. make sure set methods return a new set instead of modifying an existing one)
                        new proceed in {
                          proceed!(canceledSet.add(pubKey)) |
                          for (@canceledSet <- proceed) {
                            canceledSetStore!(canceledSet) |
                            if (canceledSet.size() < cancelQuorumSize) {
                              statusOut!({"result": true, "done": false}) |
                              doneStore!(done)
                            } else {
                              // Remove ballot from the registry so it can be garbage collected
                              @[*r, "unregister"]!(unregisterBallotToken, Nil) |
                              statusOut!({"result": true, "done": true}) |
                              doneStore!(true)
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  // create: makes a lockout.
  //
  //   ret: sends [LockoutClient, LockoutAdmin]
  contract @[*LockoutFactory, "create"](ret) = {
    new LockoutClient, LockoutAdmin, lockSetStore, addMutex in {
      // acquire: add a lock to the lockout
      //
      //   keyOut: channel on which the key to remove the new lock is sent.
      contract @[*LockoutClient, "acquire"](keyOut) = {
        for (@lockSet <- lockSetStore; _ <- addMutex) {
          new key in {
            lockSetStore!(lockSet.add(*key)) |
            addMutex!(Nil) |
            keyOut!(*key)
          }
        }
      } |
    
      // release: remove the lock for the given key
      //
      //   keyIn: key for lock to remove
      //   ack: sends on this channel when operation is complete
      contract @[*LockoutClient, "release"](@keyIn, ack) = {
        for (@lockSet <- lockSetStore) {
          lockSetStore!(lockSet.delete(keyIn)) |
          ack!(Nil)
        }
      } |
    
      // blockAcquire: prevent adding locks to the lockout.  Clients attempting
      //     to acquire will block.
      //
      //   ack: sends on this channel when operation is complete
      contract @[*LockoutAdmin, "blockAcquire"](ack) = {
        for (_ <- addMutex) {
          ack!(Nil)
        }
      } |
    
      contract @[*LockoutAdmin, "unblockAcquire"](ack) = {
        addMutex!(Nil) |
        ack!(Nil)
      } |
    
      // whenEmpty: sends on ack when lockout is empty.  Note that you must
      //     blockAcquire() before invoking this method to be sure that something
      //     doesn't acquire the lockout between the check and the notification.
      //
      //   ack: sends on this channel when lockout is empty
      contract @[*LockoutAdmin, "whenEmpty"](ack) = {
          for (@Set() <- lockSetStore) {
              lockSetStore!(Set()) |
              ack!(Nil)
          }
      } |
    
      // breakLocks: breaks all locks.  Obviously dangerous, only to be used in
      //     recovery situations.
      //
      //   ack: sends on this channel when operation is complete
      //
      // TODO: notify keyholders?
      contract @[*LockoutAdmin, "breakLocks"](ack) = {
          for (_ <- lockSetStore) {
              lockSetStore!(Set()) |
              ack!(Nil)
          }
      } |
    
      ret!([*LockoutClient, *LockoutAdmin])
    } 
  } |


  contract @[*MailBoxFactory, "create"](@pubKeySet, @sendQuorumSize, @cancelQuorumSize, recipient, mailBoxOut) = {
    new MailBoxClient, MailBoxAdmin, pubKeySetStore, sendQuorumSizeStore, cancelQuorumSizeStore,
        receiveMapStore in {
      mailBoxOut!([*MailBoxClient, *MailBoxAdmin]) |
      pubKeySetStore!(pubKeySet) |
      sendQuorumSizeStore!(sendQuorumSize) |
      cancelQuorumSizeStore!(cancelQuorumSize) |
      // Maps uuid of status ballot in source to receiving ballot in target.
      // Populated on first message received.
      receiveMapStore!({}) |
      
      // send: doesn't actually send the message cross shard---the off-chain
      //       MailBox owners notice sends to this address and deal with that.
      //       This method sets up the contract that gets the status message back
      //       from them.
      //
      //  any message: process to send cross chain.
      //  name statusOut: name on which to send a succeed/fail message back to caller
      contract @[*MailBoxClient, "send"](@message, statusOut) = {
        // Get the current params
        for (@pubKeySet <- pubKeySetStore; 
             @sendQuorumSize <- sendQuorumSizeStore; 
             @cancelQuorumSize <- cancelQuorumSizeStore) {
          // Make a ballot with those params to receive the response from the other shard
          // The winner will be the result of the attempt to send and will be sent on statusOut
          new ballotOut, winnerOut in {
            @[*BallotFactory, "create"]!(pubKeySet, sendQuorumSize, cancelQuorumSize, *winnerOut, *ballotOut) |
            for (@success, @statusBallotOrReason <- ballotOut) {
              if (success) {
                // Publish the ballot so that owners can send to it from off-chain
                new infoOut in {
                  @[*r, "register"]!(`rho:uuid`, bundle+{statusBallotOrReason}, *infoOut) |
                  for (@[statusBallotUUID, unregisterStatusBallotToken] <- infoOut) {
                    // Once the winner is received, unregister the ballot so it can be garbage
                    // collected and forward the result to the client
                    for (@winner <- winnerOut) {
                      statusOut!({"result": true, "winner": winner}) |
                      @[*r, "unregister"]!(unregisterStatusBallotToken)
                    }
                  }
                }
              } else {
                statusOut!({"result": false, "reason": statusBallotOrReason})
              }
            }
          }
        }
      } |
      
      // receive: basically *is* a ballot, but it needs to change as the parameters are updated.
      //    When sending a message above, we get to create a new ballot per send.
      //    When receiving a message, capture the current stats and use them for the whole ballot.
      // 
      //  bytearray pubkey: the public key of the owner, one of a quorum
      //  string uuid: the uuid of the contract on the other shard listening for the response.
      //      Also serves as a convenient session id.
      //  any message: the message being sent on behalf of the contract in the other shard
      //  name statusOut: a channel on which the success/failure of this invocation will be sent
      //  bytearray sig: signature over [uuid, message, *statusOut]
      contract @[*MailBoxClient, "receive"](@pubKey, @uuid, @message, statusOut, @sig) = {
        // Look up target ballot to find list of public keys
        for (@receiveMap <- receiveMapStore) {
          new ballotOut, proceed in {
            ballotOut!(receiveMap.get(uuid)) |
            for (@ballot <- ballotOut) {
              if (ballot != Nil) {
                // First message.  Get & replace current list of parameters.
                for (@pubKeySet <- pubKeySetStore; 
                     @sendQuorumSize <- sendQuorumSizeStore; 
                     @cancelQuorumSize <- cancelQuorumSizeStore) {
                  pubKeySetStore!(pubKeySet) |
                  sendQuorumSizeStore!(sendQuorumSize) |
                  cancelQuorumSizeStore!(cancelQuorumSize) |

                  // Create the ballot with the parameters
                  new ballotOut, winnerOut in {
                    @[*BallotFactory, "create"]!(pubKeySet, sendQuorumSize, cancelQuorumSize, *winnerOut, *ballotOut) |
                    for (@ballot <- ballotOut) {
                      // Add the new ballot to the map
                      receiveMapStore!(receiveMap.set(uuid, ballot)) |
                      proceed!(ballot) |
                      // Forward the winner to the recipient.  
                      // TODO(pyrocto): If that's all we were doing, we could
                      // just use recipient instead of winnerOut above, but we want to
                      // figure out how to remove the reference to the ballot from the map
                      for (@winner <- winnerOut/*; @receiveMap <- receiveMapStore*/) {
                        recipient!(winner)
                        // ???
                      }
                    }
                  }
                }
              } else {
                // Subsequent messages.
                receiveMapStore!(receiveMap) |
                proceed!(ballot)
              } |
              // Now that we have a valid ballot, forward to it.
              for (@ballot <- proceed) {
                @[ballot, "vote"]!(pubKey, message, *statusOut, sig)
              }
            }
          }
        }
      } |
      
      // updateParams is a ballot that replaces itself when the parameters get updated
      new updateParamsStore, ballotOut, winnerOut in {
        // Create an initial ballot
        @[*BallotFactory, "create"]!(pubKeySet, sendQuorumSize, cancelQuorumSize, *winnerOut, *ballotOut) |
        // Read repeatedly; this name will be reused
        for (@ballot <= ballotOut) {
          // Store the latest ballot
          updateParamsStore!(ballot) |
          // When there are new parameters
          for (@[pubKeySet, sendQuorumSize, cancelQuorumSize] <= winnerOut) {
            // Throw away the old values and the old ballot
            for (_ <- pubKeySetStore; 
                 _ <- sendQuorumSizeStore; 
                 _ <- cancelQuorumSizeStore;
                 _ <- updateParamsStore) {
              // Set the new parameters
              pubKeySetStore!(pubKeySet) |
              sendQuorumSizeStore!(sendQuorumSize) |
              cancelQuorumSizeStore!(cancelQuorumSize) |
              // Create a new ballot using the same output names so when the ballot is sent on ballotOut,
              // it gets stored in the same way the initial one did above.
              @[*BallotFactory, "create"]!(pubKeySet, sendQuorumSize, cancelQuorumSize, *winnerOut, *ballotOut)
            }
          } |
          
          // METHOD DEFINED HERE
          // TODO(pyrocto): register the mailbox somewhere? 
          //
          // updateParams: changes the set of public keys and the quorum sizes
          //
          //  bytearray pubKey: the key of the owner making this request
          //  Set(bytearray) pubKeySet: the new set of owners
          //  int sendQuorumSize: the new quorum size needed to pass a vote
          //  int cancelQuorumSize: the new quorum size needed to cancel a vote
          //  name statusOut: a channel on which the success/failure of this invocation will be sent
          //  bytearray sig: signature over [pubKeySet, sendQuorumSize, cancelQuorumSize]
          contract @[*MailBoxAdmin, "updateParams"](@pubKey, @pubKeySet, @sendQuorumSize, @cancelQuorumSize, statusOut, @sig) = {
            // Get & replace current ballot
            for (@ballot <- updateParamsStore) {
              updateParamsStore!(ballot) |
              // Pass on the info
              @[ballot, "vote"]!(pubKey, [pubKeySet, sendQuorumSize, cancelQuorumSize], *statusOut, sig)
            }
          }
        }
      }
    }
  } |

  contract @[*DepositoryFactory, "create"](@pubKeySet, @sendQuorumSize, @cancelQuorumSize, @depositoryPurse, @depositFee, depoOut) = {
    new Depository, withdrawInternal, mailBoxOut in {
      depoOut!(*Depository) |
      @[*MailBoxFactory, "create"]!(pubKeySet, sendQuorumSize, cancelQuorumSize, *withdrawInternal, *mailBoxOut) |
      for (@[mailBoxClient, mailBoxAdmin] <- mailBoxOut) {

        contract @[*Depository, "sendToChild"](@purse, @targetPubKey, statusOut) = {
          new return in {
            // Find out how much this purse has.
            @[purse, "getBalance"]!(*return) |
            for (@balance <- return) {
              new successCh in {
                // Deposit all of it to the depository.
                @[depositoryPurse, "deposit"]!(balance, purse, *successCh) |
                for (@false <- successCh) {
                  statusOut!({"result": false, "reason": "Could not deposit funds."})
                } |
                for (@true <- successCh) {
                  if (balance < depositFee) {
                    statusOut!({"result": false, "reason": "Not enough funds to pay the fee."})
                  } else {
                    // Tell child to mint a wallet containing (balance - depositFee) guarded by @targetPubKey
                    @[mailBoxClient, "send"]!([balance - depositFee, targetPubKey], *statusOut)
                  }
                }
              }
            }
          }
        } |
        
        contract @[*Depository, "withdraw"](@pubKey, @uuid, @amount, @targetPubKey, statusOut, @sig) = {
          @[mailBoxClient, "receive"]!(pubKey, uuid, [amount, targetPubKey], *statusOut, sig)
        } |

        contract @[*Depository, "updateParams"](@pubKey, @pubKeySet, @sendQuorumSize, @cancelQuorumSize, statusOut, @sig) = {
          @[mailBoxAdmin, "updateParams"]!(pubKey, pubKeySet, sendQuorumSize, cancelQuorumSize, *statusOut, sig)
        } |
        
        contract withdrawInternal(@[amount, algorithm, targetPubKey]) = {
          // create wallet from depository for amount at a new uuid guarded by the public key
          new splitPurseOut in {
            @[depositoryPurse, "split"]!(amount, *splitPurseOut) |
            // TODO(pyrocto): failure case?
            for (@[purse] <- splitPurseOut) {
              new walletOut in {
                // TODO(pyrocto): make algorithm parametric
                @"BasicWallet"!(purse, "ed25519", targetPubKey, *walletOut) |
                for (@wallet <- walletOut) {
                  @[*r, "register"]!(`rho:uuid`, bundle+{wallet}, Nil)
                }
              }
            }
          }
        }
      }
    }
  } |
  
  contract @[*MintFactory, "create"](@pubKeySet, @sendQuorumSize, @cancelQuorumSize, @depositFee, mintOut) = {
    new Mint, mintInternal, mailBoxOut, underlyingMintOut in {
      mintOut!(*Mint) |
      @"MakeMint"!(*underlyingMintOut) |
      @[*MailBoxFactory, "create"]!(pubKeySet, sendQuorumSize, cancelQuorumSize, *mintInternal, *mailBoxOut) |
      
      for (@[mailBoxClient, mailBoxAdmin] <- mailBoxOut) {

        contract @[*Mint, "sendToParent"](@purse, @targetPubKey, statusOut) = {
          new return in {
            // Find out how much this purse has.
            @[purse, "getBalance"]!(*return) |
            for (@balance <- return) {
              new splitPurseOut in {
                // Create new wallet, transfer funds
                @[purse, "split"]!(balance, *splitPurseOut) |
                for (@[] <- splitPurseOut) {
                  statusOut!({"result": false, "reason": "Could not deposit funds."})
                } |
                // Throw away the resulting purse.
                for (@[_] <- splitPurseOut) {
                  if (balance < depositFee) {
                    statusOut!({"result": false, "reason": "Not enough funds to pay the fee."})
                  } else {
                    // Tell parent to withdraw (balance - depositFee) from depository to a wallet guarded by @targetPubKey
                    @[mailBoxClient, "send"]!([balance - depositFee, targetPubKey], *statusOut)
                  }
                }
              }
            }
          }
        } |
        
        contract @[*Mint, "mint"](@pubKey, @uuid, @amount, @targetPubKey, statusOut, @sig) = {
          @[mailBoxClient, "receive"]!(pubKey, uuid, [amount, targetPubKey], *statusOut, sig)
        } |

        contract @[*Mint, "updateParams"](@pubKey, @pubKeySet, @sendQuorumSize, @cancelQuorumSize, statusOut, @sig) = {
          @[mailBoxAdmin, "updateParams"]!(pubKey, pubKeySet, sendQuorumSize, cancelQuorumSize, *statusOut, sig)
        } |
        
        for (@underlyingMint <- underlyingMintOut) {
          contract mintInternal(@[amount, targetPubKey]) = {
            // create wallet for amount at a new uuid guarded by the public key
            new purseOut in {
              @[underlyingMint, "makePurse"]!(amount, *purseOut) |
              for (@purse <- purseOut) {
                new walletOut in {
                  // TODO(pyrocto): make algorithm parametric
                  @"BasicWallet"!(purse, "ed25519", targetPubKey, *walletOut) |
                  for (@wallet <- walletOut) {
                    @[*r, "register"]!(`rho:uuid`, bundle+{wallet}, Nil)
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
